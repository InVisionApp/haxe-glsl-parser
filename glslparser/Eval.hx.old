/*
	GLSL Eval

	- Eval's purpose is to evaluate an expression and return a Primitive
	- Eval should never modify the ast
	- For now, Eval supports only constant expressions

	@author George Corney

	#Todo
	- handle complex construction:

		mat2 m2x2 = mat2(
		   1.1, 2.1, 
		   1.2, 2.2
		);
		mat3 m3x3 = mat3(m2x2); // = mat3(
		   // 1.1, 2.1, 0.0,   
		   // 1.2, 2.2, 0.0,
		   // 0.0, 0.0, 1.0)
		mat2 mm2x2 = mat2(m3x3); // = m2x2

	- handle basic conversion in constructors, constructs seem to be completely type flexible!
	- Arrays: const should be stored as VariableDefinition which includes array behavior
	- a VariableDefintion encapsulates a GLSLDataPrimitive
*/

package glslparser;

import glslparser.AST;
import haxe.macro.Expr;

class Eval{
	static var builtInConstants:Map<String, GLSLDataPrimitive> = [
		'gl_MaxVertexAttribs'             => DataLiteral(8, INT),
		'gl_MaxVertexUniformVectors'      => DataLiteral(128, INT),
		'gl_MaxVaryingVectors'            => DataLiteral(8, INT),
		'gl_MaxVertexTextureImageUnits'   => DataLiteral(0, INT),
		'gl_MaxCombinedTextureImageUnits' => DataLiteral(8, INT),
		'gl_MaxTextureImageUnits'         => DataLiteral(8, INT),
		'gl_MaxFragmentUniformVectors'    => DataLiteral(16, INT),
		'gl_MaxDrawBuffers'               => DataLiteral(1, INT)
	];
	static var builtInTypeDefinitions:Map<DataType, GLSLBuiltInTypeDefinition> = [
		VEC2  => new GLSLBuiltInTypeDefinition(FLOAT, 2),
		VEC3  => new GLSLBuiltInTypeDefinition(FLOAT, 3),
		VEC4  => new GLSLBuiltInTypeDefinition(FLOAT, 4),
		BVEC2 => new GLSLBuiltInTypeDefinition(BOOL, 2),
		BVEC3 => new GLSLBuiltInTypeDefinition(BOOL, 3),
		BVEC4 => new GLSLBuiltInTypeDefinition(BOOL, 4),
		IVEC2 => new GLSLBuiltInTypeDefinition(INT, 2),
		IVEC3 => new GLSLBuiltInTypeDefinition(INT, 3),
		IVEC4 => new GLSLBuiltInTypeDefinition(INT, 4),
		MAT2  => new GLSLBuiltInTypeDefinition(MAT2, 2*2),
		MAT3  => new GLSLBuiltInTypeDefinition(MAT3, 3*3),
		MAT4  => new GLSLBuiltInTypeDefinition(MAT4, 4*4),
	];

	static var userDefinedConstants:Map<String, GLSLDataPrimitive> = new Map<String, GLSLDataPrimitive>();
	static var userDefinedTypes:Map<DataType, GLSLStructDefinition> = new Map<DataType, GLSLStructDefinition>();

	static public var warnings:Array<String> = new Array<String>();

	static public function reset(){
		//init state machine
		userDefinedConstants = new Map<String, GLSLDataPrimitive>();
		userDefinedTypes = new Map<DataType, GLSLStructDefinition>();
		warnings = new Array<String>();
	}

	// static public function getConstant(name:String){
	// 	if(userDefinedConstants.exists(name)) return userDefinedConstants.get(name);
	// 	if(builtInConstants.exists(name)) return builtInConstants.get(name);
	// 	return null;
	// }

	// static public function getType(dataType:DataType){
	// 	if(userDefinedTypes.exists(dataType)) return userDefinedTypes.get(dataType);
	// 	// if(builtInTypes.exists(dataType)) return builtInTypes.get(dataType);
	// 	return null;
	// }

	static public function defineType(specifier:StructSpecifier){
		userDefinedTypes.set(DataType.USER_TYPE(specifier.name), GLSLStructDefinition.fromStructSpecifier(specifier));
		// trace('defining user type ${specifier.name}');
	}

	static public function defineVariable(declaration:VariableDeclaration){

	}

	// static public function defineConst(declarator:Declarator){
	// 	var dataPrimitive = resolveExpression(declarator.initializer);
	// 	userDefinedConstants.set(declarator.name, dataPrimitive);
	// 	// trace('defining const ${declarator.name} as $resolvedExpr');
	// 	return dataPrimitive;
	// }

	//#! temporary while developing
	static public function evaluateConstantExpressions(ast:Node):Void{
		reset();
		iterate(ast);
	}

	//#! this functionality should be moved to the client
	static function iterate(node:Dynamic){
		
		switch (Type.getClass(node)) {
			case Array: var _ = cast(node, Array<Dynamic>);
				for(i in 0..._.length) iterate(_[i]);

			case VariableDeclaration: var _ = cast(node, VariableDeclaration);
				iterate(_.typeSpecifier);
				if(_.typeSpecifier.qualifier == CONST){
					for(i in 0..._.declarators.length){
						var initPrimitive = defineConst(_.declarators[i]);
						switch initPrimitive {
							case DataLiteral(v, dt):
								if(!dt.equals(_.typeSpecifier.dataType))
								warn('type mismatch'); //#! needs more info, should we even be testing for this here, rather than in a separate validation phase?
							default: 
						}
					}
				}

			case StructSpecifier: var _ = cast(node, StructSpecifier);
				defineType(_);
				iterate(_.structDeclarations);

			case StructDeclaration: var _ = cast(node, StructDeclaration);
				iterate(_.typeSpecifier);

			default:
				// trace('default case'); //#!
		}

	}

	//collapses constant expression down to a data primitive
	static function resolveExpression(expr:Expression):GLSLDataPrimitive{
		switch (Type.getClass(expr)) {
			//fully resolved expressions
			case Literal: var _ = cast(expr, Literal<Dynamic>);
				return DataLiteral(_.value, _.dataType);

			case Constructor: var _ = cast(expr, Constructor);
				//resolve parameters
				// for(i in 0..._.parameters.length)
				// 	_.parameters[i] = resolveExpression(_.parameters[i]);
				// return _;

			// case FunctionCall: var _ = cast(expr, FunctionCall);
				//cannot handle function call

			//not fully resolved
			case Identifier: var _ = cast(expr, Identifier);
				var c = getConstant(_.name);
				if(c == null) warn('${_.name} has not been defined in this scope');
				return c;

			case BinaryExpression: var _ = cast(expr, BinaryExpression);
				return resolveBinaryExpression(_);

			case UnaryExpression: var _ = cast(expr, UnaryExpression);

			case SequenceExpression: var _ = cast(expr, SequenceExpression);

			case ConditionalExpression: var _ = cast(expr, ConditionalExpression);

			case AssignmentExpression: var _ = cast(expr, AssignmentExpression);
				//#need to resolving the unary left expression as well as the right

			case FieldSelectionExpression: var _ = cast(expr, FieldSelectionExpression);
				// try{
				// 	var left = cast(resolveExpression(_.left), Constructor);
				// 	var typeDefinition = getType(left.dataType);
				// 	return typeDefinition.accessField(_.field.name, left.parameters);
				// }catch(error:Dynamic){
				// 	warn(error);
				// 	warn('could not access field ${_.field.name}'); //#! needs more info
				// }

			case ArrayElementSelectionExpression: var _ = cast(expr, ArrayElementSelectionExpression);
				//in general this can act on any variable including consts but in glsl es it's restricted to complex types
				// try{
				// 	var a = resolveExpression(_.arrayIndexExpression);
				// 	if(a.dataType != INT){
				// 		Eval.warn('array size must an integer expression');
				// 		return null;
				// 	}
				// 	var av = cast(a, Literal<Dynamic>);
				// 	//assume the left expression is a constructor since ES 1.0 does not allow array initialization
				// 	var left = cast(resolveExpression(_.left), Constructor);
				// 	var typeDefinition = builtInTypes.get(left.dataType); //array access is not possible on structs
				// 	return typeDefinition.accessIndex(av.value, left.parameters);
				// }catch(error:Dynamic){
				// 	warn(error);
				// 	warn('array access not possible'); //#! needs more info
				// }

		}

		warn('cannot resolve expression $expr');
		return null;
	}

	static function resolveBinaryExpression(binExpr:BinaryExpression):GLSLDataPrimitive{
		var left = resolveExpression(binExpr.left);
		var right = resolveExpression(binExpr.right);
		var op = binExpr.op;

		switch (BinaryOp(left, right, op)) {
			//STAR
			case BinaryOp(DataLiteral(lv, INT), DataLiteral(rv, INT), STAR):
				return DataLiteral(Math.floor(lv * rv), INT);
			case BinaryOp(DataLiteral(lv, FLOAT), DataLiteral(rv, FLOAT), STAR):
				return DataLiteral(lv * rv, FLOAT);
			//SLASH
			case BinaryOp(DataLiteral(lv, INT), DataLiteral(rv, INT), SLASH):
				return DataLiteral(Math.floor(lv / rv), INT);
			case BinaryOp(DataLiteral(lv, FLOAT), DataLiteral(rv, FLOAT), SLASH):
				return DataLiteral(lv / rv, FLOAT);
			//PERCENT
			case BinaryOp(DataLiteral(lv, INT), DataLiteral(rv, INT), PERCENT):
				return DataLiteral(Math.floor(lv % rv), INT);
			case BinaryOp(DataLiteral(lv, FLOAT), DataLiteral(rv, FLOAT), PERCENT):
				return DataLiteral(Math.floor(lv % rv), FLOAT);
			//PLUS
			case BinaryOp(DataLiteral(lv, INT), DataLiteral(rv, INT), PLUS):
				return DataLiteral(Math.floor(lv + rv), INT);
			case BinaryOp(DataLiteral(lv, FLOAT), DataLiteral(rv, FLOAT), PLUS):
				return DataLiteral(lv + rv, FLOAT);
			//DASH
			case BinaryOp(DataLiteral(lv, INT), DataLiteral(rv, INT), DASH):
				return DataLiteral(Math.floor(lv - rv), INT);
			case BinaryOp(DataLiteral(lv, FLOAT), DataLiteral(rv, FLOAT), DASH):
				return DataLiteral(lv - rv, FLOAT);
			//LEFT_ANGLE
			case BinaryOp(DataLiteral(lv, INT), DataLiteral(rv, INT), LEFT_ANGLE):
				return DataLiteral(lv < rv, BOOL);
			case BinaryOp(DataLiteral(lv, FLOAT), DataLiteral(rv, FLOAT), LEFT_ANGLE):
				return DataLiteral(lv < rv, BOOL);
			//RIGHT_ANGLE
			case BinaryOp(DataLiteral(lv, INT), DataLiteral(rv, INT), RIGHT_ANGLE):
				return DataLiteral(lv > rv, BOOL);
			case BinaryOp(DataLiteral(lv, FLOAT), DataLiteral(rv, FLOAT), RIGHT_ANGLE):
				return DataLiteral(lv > rv, BOOL);
			//LE_OP
			case BinaryOp(DataLiteral(lv, INT), DataLiteral(rv, INT), LE_OP):
				return DataLiteral(lv <= rv, BOOL);
			case BinaryOp(DataLiteral(lv, FLOAT), DataLiteral(rv, FLOAT), LE_OP):
				return DataLiteral(lv <= rv, BOOL);
			//GE_OP
			case BinaryOp(DataLiteral(lv, INT), DataLiteral(rv, INT), GE_OP):
				return DataLiteral(lv >= rv, BOOL);
			case BinaryOp(DataLiteral(lv, FLOAT), DataLiteral(rv, FLOAT), GE_OP):
				return DataLiteral(lv >= rv, BOOL);
			//EQ_OP
			case BinaryOp(DataLiteral(lv, INT), DataLiteral(rv, INT), EQ_OP):
				return DataLiteral(lv == rv, BOOL);
			case BinaryOp(DataLiteral(lv, FLOAT), DataLiteral(rv, FLOAT), EQ_OP):
				return DataLiteral(lv == rv, BOOL);
			case BinaryOp(DataLiteral(lv, BOOL), DataLiteral(rv, BOOL), EQ_OP):
				return DataLiteral(lv == rv, BOOL);
			//NE_OP
			case BinaryOp(DataLiteral(lv, INT), DataLiteral(rv, INT), NE_OP):
				return DataLiteral(lv != rv, BOOL);
			case BinaryOp(DataLiteral(lv, FLOAT), DataLiteral(rv, FLOAT), NE_OP):
				return DataLiteral(lv != rv, BOOL);
			//LEFT_OP
			case BinaryOp(DataLiteral(lv, INT), DataLiteral(rv, INT), LEFT_OP):
				return DataLiteral(Math.floor(lv << rv), INT);
			//RIGHT_OP
			case BinaryOp(DataLiteral(lv, INT), DataLiteral(rv, INT), RIGHT_OP):
				return DataLiteral(Math.floor(lv >> rv), INT);
			//AMPERSAND
			case BinaryOp(DataLiteral(lv, INT), DataLiteral(rv, INT), AMPERSAND):
				return DataLiteral(Math.floor(lv & rv), INT);
			//CARET
			case BinaryOp(DataLiteral(lv, INT), DataLiteral(rv, INT), CARET):
				return DataLiteral(Math.floor(lv ^ rv), INT);
			//VERTICAL_BAR
			case BinaryOp(DataLiteral(lv, INT), DataLiteral(rv, INT), VERTICAL_BAR):
				return DataLiteral(Math.floor(lv | rv), INT);
			//AND_OP
			case BinaryOp(DataLiteral(lv, BOOL), DataLiteral(rv, BOOL), AND_OP):
				return DataLiteral(lv && rv, BOOL);
			//XOR_OP
			case BinaryOp(DataLiteral(lv, BOOL), DataLiteral(rv, BOOL), XOR_OP):
				return DataLiteral(!lv != !rv, BOOL);
			//OR_OP
			case BinaryOp(DataLiteral(lv, BOOL), DataLiteral(rv, BOOL), OR_OP):
				return DataLiteral(lv || rv, BOOL);
			default:
		}

		warn('could not resolve binary expression $left $op $right'); //#! needs improving
		return null;
	}

	static function resolveUnaryExpression(unExpr:UnaryExpression):GLSLDataPrimitive{
		//we need to be careful which expressions different operators can act on

		// switch (UnaryOp(argType, unExpr.op, unExpr.isPrefix)) {
		// 	case UnaryOp(INT, INC_OP, isPrefix):
		// 		// alter arg?
		// 		// return DataLiteral(r, INT);
		// }

		warn('could not resolve unary expression $unExpr'); //#! needs improving
		return null;
	}


	//Error Reporting
	static function warn(msg){
		warnings.push('Eval warning: $msg');
	}

	static function error(msg){
		throw 'Eval error: $msg';
	}
}

enum GLSLDataPrimitive{
	DataLiteral(v:Dynamic, t:DataType);
	DataComplex();
}

enum OperationType{
	BinaryOp(l:GLSLDataPrimitive, r:GLSLDataPrimitive, op:BinaryOperator);
	UnaryOp(arg:GLSLDataPrimitive, op:UnaryOperator, isPrefix:Bool);
}


//Definitions
typedef GLSLFieldDefinition = {
	var dataType:DataType;
	var name:String;
	@:optional var arraySize:Int;
}

typedef GLSLFieldInstance = {
	var dataType:DataType;
	var value:GLSLDataPrimitive;
	@:optional var arraySize:Int;
}

interface GLSLFieldAccess{
	public function accessField(name:String):GLSLDataPrimitive;
}

interface GLSLArrayAccess{
	public function accessIndex(i:Int):GLSLDataPrimitive;
}

@:access(glslparser.Eval)
class GLSLStructDefinition{
	public var name:String;
	public var fields:Array<GLSLFieldDefinition>;

	public function new(name:String, fields:Array<GLSLFieldDefinition>){
		this.name = name;
		this.fields = fields;
	}

	public function createInstance(?constructionParams:Array<GLSLDataPrimitive>):GLSLStructInstance{
		return new GLSLStructInstance(this, constructionParams);
	}

	static public function fromStructSpecifier(specifier:StructSpecifier){
		//convert declarations to fields
		var fields = new Array<GLSLFieldDefinition>();
		for(i in 0...specifier.structDeclarations.length){
			var d = specifier.structDeclarations[i];
			var type = d.typeSpecifier.dataType;
			for(j in 0...d.declarators.length){
				var dr = d.declarators[j];

				var field:GLSLFieldDefinition = {dataType: type, name: dr.name};

				if(Type.getClass(dr) == StructArrayDeclarator){
					//resolve array expression
					var arraySizePrimitive = Eval.resolveExpression(cast(dr, StructArrayDeclarator).arraySizeExpression);
					switch arraySizePrimitive{
						case DataLiteral(v, INT):
							field.arraySize = v;
						default:
							Eval.error('array size must an integer expression');
					}
				}

				fields.push(field);
			}
		}

		return new GLSLStructDefinition(specifier.name, fields);
	}
}

class GLSLBuiltInTypeDefinition {
	var fieldsType:DataType;
	var fieldsCount:Int;

	public function new(fieldsType:DataType, fieldsCount:Int){
		this.fieldsType = fieldsType;
		this.fieldsCount = fieldsCount;
	}
}


//Instances
@:access(glslparser.Eval)
class GLSLStructInstance implements GLSLFieldAccess{
	var type:GLSLStructDefinition;
	var fields:Map<String, GLSLFieldInstance>;

	public function new(type:GLSLStructDefinition, ?constructionParams:Array<GLSLDataPrimitive>){
		this.type = type;

		fields =  new Map<String, GLSLFieldInstance>();

		//create fields
		for(i in 0...type.fields.length){
			var f = type.fields[i];
			var fieldInst = {
				dataType: f.dataType,
				arraySize: f.arraySize,
				value: null
			};
			fields.set(f.name, fieldInst);
		}

		if(constructionParams != null)
			construct(constructionParams);
	}

	public function construct(constructionParams:Array<GLSLDataPrimitive>){
		//fuzzy typing
		//what happens if not all parameters are set?
		for(i in 0...constructionParams.length){
			var c = constructionParams[i];
			var f = fields.get(fieldName(i));

		}
	}
	
	public function accessField(name:String){
		return fields.get(name).value;
	}

	inline function fieldName(i:Int):String{
		return type.fields[i].name;
	}
}


@:access(glslparser.Eval)
class GLSLBuiltInInstance implements GLSLFieldAccess implements GLSLArrayAccess{
	public function accessField(string:String){
		//{x, y, z, w}
		//{r, g, b, a}
		//{s, t, p, q}
		//No more than 4 components can be selected.

		//need to create a construction routine to handle filling the type from the construction params,
		//must be able to deal with constructions like
		//mat3 m3x3 = mat3(m2x2);
		return null;
	}

	public function accessIndex(i:Int):GLSLDataPrimitive{
		//return rows for mat and fields for vec
		return null;
	}
}